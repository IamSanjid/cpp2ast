const std = @import("std");
const cpp2ast = @import("cpp2ast");
const clang = cpp2ast.clang;
const t = cpp2ast.traversers;
const BasicString = cpp2ast.common.BasicString;

pub fn bindings(allocator: std.mem.Allocator, header_path: []const u8) !BasicString {
    // c_cxx_includes module is generated by cpp2ast build.zig and is exposed as zig_c_cxx_includes
    // it's just the absolute path to zig's bundled clang runtime include dirs and libc include dirs.
    const c_cxx_includes = cpp2ast.zig_c_cxx_includes;
    var sys_include_dirs = std.ArrayList([]const u8).init(allocator);
    defer sys_include_dirs.deinit();
    for (c_cxx_includes.libc) |libc| {
        try sys_include_dirs.append(libc);
    }
    try sys_include_dirs.append(c_cxx_includes.clang_rt);
    try sys_include_dirs.append(c_cxx_includes.libcxx);

    const index_header = try std.fs.path.join(allocator, &.{ header_path, "clang-c", "Index.h" });
    defer allocator.free(index_header);

    // every source is parsed as c++ by the "default" function,
    // if need to control everything `clang.TranslationUnit.parse` can be used
    var translation_unit = try cpp2ast.traversers.createTranslationUnitDefault(
        allocator,
        &.{index_header},
        &.{header_path},
        sys_include_dirs.items,
    );
    defer translation_unit.deinit();
    try translation_unit.printAndCheckDiags();

    var root_cursor = translation_unit.cursor();

    const root_childs = try root_cursor.collectChildren(allocator);
    defer root_childs.deinit();
    std.debug.assert(root_childs.items.len > 0);

    var gen_builder = BasicString.init(allocator);

    try gen_builder.append(
        \\pub const c = @cImport({
        \\    @cInclude("clang-c/Index.h");
        \\    @cInclude("stdio.h");
        \\});
        \\
    );

    for (root_childs.items) |root_child| {
        if (root_child.isInSystemHeader()) continue;

        switch (root_child.kind()) {
            // since it's a c++ source and by default clang-c/Index.h does `extern "C"` stuff
            clang.CursorKind.LinkageSpec => {
                const current_context = .{ .allocator = allocator, .gen_builder = &gen_builder };
                const visitor = struct {
                    fn func(context: @TypeOf(current_context), child: clang.Cursor, _: clang.Cursor) !void {
                        switch (child.kind()) {
                            clang.CursorKind.EnumDecl => {
                                try generateEnumBindings(child, context.allocator, context.gen_builder);
                            },
                            clang.CursorKind.FunctionDecl => {
                                try generateEnumFuncBindings(child, context.allocator, context.gen_builder);
                            },
                            else => {},
                        }
                    }
                }.func;
                _ = root_child.visit(current_context, visitor);
            },
            else => {},
        }
    }

    return gen_builder;
}

const isCursorInteresting = struct {
    fn func(cur: clang.Cursor, space_creator: std.mem.Allocator, ret_spelling: ?*[]const u8) bool {
        const cur_spelling = cur.spelling(space_creator) catch return false;
        const result = std.mem.eql(u8, "CXCursorKind", cur_spelling) or
            std.mem.eql(u8, "CXTypeKind", cur_spelling);
        if (ret_spelling) |spelling| {
            spelling.* = cur_spelling;
        } else {
            space_creator.free(cur_spelling);
        }
        return result;
    }
}.func;

fn generateEnumBindings(cursor: clang.Cursor, allocator: std.mem.Allocator, gen_builder: *BasicString) !void {
    const c_type = t.cursorToDeclType(cursor);

    const enum_ty = try t.EnumType.fromType(allocator, c_type);
    defer enum_ty.deinit();

    var cur_spelling: []const u8 = undefined;
    defer allocator.free(cur_spelling);

    if (!isCursorInteresting(enum_ty.cursor, allocator, &cur_spelling)) return;

    const tag_type_str = switch (enum_ty.tag_type) {
        .Bool, .Int => "c_int",
        .UInt => "c_uint",
        else => unreachable,
    };

    var used_variant_values: [800]bool = std.mem.zeroes([800]bool);
    var decl_variants = std.ArrayList([]const u8).init(allocator);
    defer {
        for (decl_variants.items) |decl| {
            allocator.free(decl);
        }
        decl_variants.deinit();
    }
    // skipping `CX` of the start
    const enum_name = cur_spelling[2..];
    try gen_builder.appendFmt("pub const {s} = enum({s}) {{\n", .{ enum_name, tag_type_str });
    for (enum_ty.variants.items) |variant| {
        const variant_spelling = try variant[0].spelling(allocator);
        defer allocator.free(variant_spelling);
        var variant_name = variant_spelling;
        if (std.mem.indexOf(u8, variant_name, "_")) |pos| {
            variant_name = variant_name[pos + 1 ..];
        }
        const variant_name_starts_first = std.mem.startsWith(u8, variant_name, "First");
        const variant_name_starts_last = std.mem.startsWith(u8, variant_name, "Last");
        switch (variant[1].?) {
            .UInt => |v| {
                if (variant_name_starts_first or variant_name_starts_last or used_variant_values[v]) {
                    try decl_variants.append(
                        try std.fmt.allocPrint(allocator, "pub const {s}: {s} = @enumFromInt({});", .{ variant_name, enum_name, v }),
                    );
                    continue;
                }
                used_variant_values[v] = true;
                try gen_builder.appendFmt("    {s} = {},\n", .{ variant_name, v });
            },
            .Int => |v| {
                const v_as_index: usize = @intCast(v);
                if (variant_name_starts_first or variant_name_starts_last or used_variant_values[v_as_index]) {
                    try decl_variants.append(
                        try std.fmt.allocPrint(allocator, "pub const {s}: {s} = @enumFromInt({});", .{ variant_name, enum_name, v }),
                    );
                    continue;
                }
                used_variant_values[v_as_index] = true;
                try gen_builder.appendFmt("    {s} = {},\n", .{ variant_name, v });
            },
            else => unreachable,
        }
    }
    try gen_builder.appendFmt("    pub const TagType = {s};\n", .{tag_type_str});
    for (decl_variants.items) |decl| {
        try gen_builder.appendFmt("    {s}\n", .{decl});
    }
    try gen_builder.append("};\n");
}

// why the dupe(s)? coz lazy...
// includes `c.` prefix for non primitive types
const toCTypeStr = struct {
    fn func(c_type: clang.Type, space_creator: std.mem.Allocator, wrap_type: *bool) ![]const u8 {
        wrap_type.* = false;
        return switch (t.TypeTag.fromType(c_type)) {
            .UInt => space_creator.dupe(u8, "c_uint"),
            .Int => space_creator.dupe(u8, "c_int"),
            .Pointer, .Array => blk: {
                const child_c_type = c_type.pointeeType() orelse c_type.elemType() orelse unreachable;
                const child_type_str = try @This().func(child_c_type, space_creator, wrap_type);
                defer space_creator.free(child_type_str);
                break :blk std.fmt.allocPrint(space_creator, "[*c]{s}", .{child_type_str});
            },
            else => blk: {
                // arena allocator is probably best for such cases...
                if (t.c_typeToCanonTypeDefFallible(c_type)) |cur| {
                    var cur_spelling: []const u8 = undefined;
                    defer space_creator.free(cur_spelling);
                    if (isCursorInteresting(cur, space_creator, &cur_spelling)) {
                        // skipping `CX`
                        wrap_type.* = true;
                        break :blk space_creator.dupe(u8, cur_spelling[2..]);
                    }
                }
                const type_spelling = @constCast(try c_type.spelling(space_creator));
                defer space_creator.free(type_spelling);
                std.mem.replaceScalar(u8, type_spelling, ' ', '_');
                break :blk std.fmt.allocPrint(space_creator, "c.{s}", .{type_spelling});
            },
        };
    }
}.func;

fn generateEnumFuncBindings(cursor: clang.Cursor, allocator: std.mem.Allocator, gen_builder: *BasicString) !void {
    const func_info = try t.FunctionInfo.fromCur(cursor);

    var interested = false;
    if (t.c_typeToCanonTypeDefFallible(func_info.ret_c_type)) |cur| {
        interested = isCursorInteresting(cur, allocator, null);
    }
    const args = try func_info.args(allocator);
    defer args.deinit();

    if (!interested) {
        for (args.items) |arg| {
            if (t.c_typeToCanonTypeDefFallible(arg.c_type())) |cur| {
                if (isCursorInteresting(cur, allocator, null)) {
                    interested = true;
                    break;
                }
            }
        }
    }

    if (!interested) return;

    var wrap_ret = false;
    const return_str = try toCTypeStr(func_info.ret_c_type, allocator, &wrap_ret);
    defer allocator.free(return_str);

    const func_name = try func_info.name(allocator);
    defer allocator.free(func_name);

    var forward_builder = BasicString.init(allocator);
    defer forward_builder.deinit();

    try gen_builder.appendFmt("pub inline fn {s}(", .{func_name});
    for (args.items, 0..) |arg, i| {
        var arg_name = try arg.spelling(allocator);
        defer allocator.free(arg_name);
        if (arg_name.len == 0) {
            allocator.free(arg_name);
            arg_name = try std.fmt.allocPrint(allocator, "arg{}", .{i});
        }
        var wrap_type = false;
        const type_str = try toCTypeStr(arg.c_type(), allocator, &wrap_type);
        defer allocator.free(type_str);
        if (i > 0) {
            try gen_builder.appendFmt(", {s}: {s}", .{ arg_name, type_str });
            if (wrap_type) {
                try forward_builder.appendFmt(", @intFromEnum({s})", .{arg_name});
            } else {
                try forward_builder.appendFmt(", {s}", .{arg_name});
            }
        } else {
            try gen_builder.appendFmt("{s}: {s}", .{ arg_name, type_str });
            if (wrap_type) {
                try forward_builder.appendFmt("@intFromEnum({s})", .{arg_name});
            } else {
                try forward_builder.appendFmt("{s}", .{arg_name});
            }
        }
    }
    try gen_builder.appendFmt(") {s} {{\n", .{return_str});
    if (wrap_ret) {
        try gen_builder.appendFmt("    return @enumFromInt(c.{s}({s}));\n", .{ func_name, forward_builder.str() });
    } else {
        try gen_builder.appendFmt("    return c.{s}({s});\n", .{ func_name, forward_builder.str() });
    }
    try gen_builder.append("}\n");
}
