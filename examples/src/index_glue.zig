const std = @import("std");
const index_common = @import("index_common.zig");
const cpp2ast = @import("cpp2ast");

const ToZig = index_common.ToZig;
const isCursorInteresting = index_common.isCursorInteresting;
const toZigTypeStr = index_common.toZigTypeStr;
const interested_cursor_spelling = index_common.interested_cursor_spelling;

const clang = cpp2ast.clang;
const t = cpp2ast.traversers;
const BasicString = cpp2ast.common.BasicString;

pub fn generate_header(allocator: std.mem.Allocator, header_path: []const u8) !BasicString {
    // c_cxx_includes module is generated by cpp2ast build.zig and is exposed as zig_c_cxx_includes
    // it's just the absolute path to zig's bundled clang runtime include dirs and libc include dirs.
    const c_cxx_includes = cpp2ast.zig_c_cxx_includes;
    var sys_include_dirs = std.ArrayList([]const u8).init(allocator);
    defer sys_include_dirs.deinit();
    for (c_cxx_includes.libc) |libc| {
        try sys_include_dirs.append(libc);
    }
    try sys_include_dirs.append(c_cxx_includes.clang_rt);
    try sys_include_dirs.append(c_cxx_includes.libcxx);

    const index_header = try std.fs.path.join(allocator, &.{ header_path, "clang-c", "Index.h" });
    defer allocator.free(index_header);

    // `createTranslationUnitDefault` will treat every source as c++ by passing `-x c++` option to libclang,
    // if need to control everything `clang.TranslationUnit.parse` can be used
    var translation_unit = try cpp2ast.traversers.createTranslationUnitDefault(
        allocator,
        &.{index_header},
        &.{header_path},
        sys_include_dirs.items,
    );
    defer translation_unit.deinit();
    try translation_unit.printAndCheckDiags();

    var root_cursor = translation_unit.cursor();

    const root_childs = try root_cursor.collectChildren(allocator);
    defer root_childs.deinit();
    std.debug.assert(root_childs.items.len > 0);

    var gen_builder = BasicString.init(allocator);
    var glue_needed = false;

    try gen_builder.append("#ifndef __ZIG_LLVM_CLANG_C_GLUE_H__\n");
    try gen_builder.append("#define __ZIG_LLVM_CLANG_C_GLUE_H__\n");
    try gen_builder.append("#include <clang-c/Index.h>\n");
    try gen_builder.append("LLVM_CLANG_C_EXTERN_C_BEGIN\n");

    for (root_childs.items) |root_child| {
        if (root_child.isInSystemHeader()) continue;

        switch (root_child.kind()) {
            // since it's a c++ source and by default clang-c/Index.h does `extern "C"` stuff
            clang.CursorKind.LinkageSpec => {
                const current_context = .{
                    .allocator = allocator,
                    .gen_builder = &gen_builder,
                    .glue_needed = &glue_needed,
                };
                const visitor = struct {
                    fn func(context: @TypeOf(current_context), child: clang.Cursor, _: clang.Cursor) !void {
                        switch (child.kind()) {
                            clang.CursorKind.StructDecl => {
                                try generateStructSetters(
                                    child,
                                    context.allocator,
                                    context.gen_builder,
                                    context.glue_needed,
                                    true,
                                );
                            },
                            else => {},
                        }
                    }
                }.func;
                _ = root_child.visit(current_context, visitor);
            },
            else => {},
        }
    }

    try gen_builder.append("LLVM_CLANG_C_EXTERN_C_END\n");
    try gen_builder.append("#endif // __ZIG_LLVM_CLANG_C_GLUE_H__\n");
    return gen_builder;
}

pub fn generate_source(allocator: std.mem.Allocator, header_path: []const u8, gen_header_path: []const u8) !BasicString {
    // c_cxx_includes module is generated by cpp2ast build.zig and is exposed as zig_c_cxx_includes
    // it's just the absolute path to zig's bundled clang runtime include dirs and libc include dirs.
    const c_cxx_includes = cpp2ast.zig_c_cxx_includes;
    var sys_include_dirs = std.ArrayList([]const u8).init(allocator);
    defer sys_include_dirs.deinit();
    for (c_cxx_includes.libc) |libc| {
        try sys_include_dirs.append(libc);
    }
    try sys_include_dirs.append(c_cxx_includes.clang_rt);
    try sys_include_dirs.append(c_cxx_includes.libcxx);

    const index_header = try std.fs.path.join(allocator, &.{ header_path, "clang-c", "Index.h" });
    defer allocator.free(index_header);

    // `createTranslationUnitDefault` will treat every source as c++ by passing `-x c++` option to libclang,
    // if need to control everything `clang.TranslationUnit.parse` can be used
    var translation_unit = try cpp2ast.traversers.createTranslationUnitDefault(
        allocator,
        &.{index_header},
        &.{header_path},
        sys_include_dirs.items,
    );
    defer translation_unit.deinit();
    try translation_unit.printAndCheckDiags();

    var root_cursor = translation_unit.cursor();

    const root_childs = try root_cursor.collectChildren(allocator);
    defer root_childs.deinit();
    std.debug.assert(root_childs.items.len > 0);

    var gen_builder = BasicString.init(allocator);
    try gen_builder.appendFmt("#include \"{s}\"\n", .{gen_header_path});
    try gen_builder.append("LLVM_CLANG_C_EXTERN_C_BEGIN\n");

    var glue_needed = false;

    for (root_childs.items) |root_child| {
        if (root_child.isInSystemHeader()) continue;

        switch (root_child.kind()) {
            // since it's a c++ source and by default clang-c/Index.h does `extern "C"` stuff
            clang.CursorKind.LinkageSpec => {
                const current_context = .{
                    .allocator = allocator,
                    .gen_builder = &gen_builder,
                    .glue_needed = &glue_needed,
                };
                const visitor = struct {
                    fn func(context: @TypeOf(current_context), child: clang.Cursor, _: clang.Cursor) !void {
                        switch (child.kind()) {
                            clang.CursorKind.StructDecl => {
                                try generateStructSetters(
                                    child,
                                    context.allocator,
                                    context.gen_builder,
                                    context.glue_needed,
                                    false,
                                );
                            },
                            else => {},
                        }
                    }
                }.func;
                _ = root_child.visit(current_context, visitor);
            },
            else => {},
        }
    }

    try gen_builder.append("LLVM_CLANG_C_EXTERN_C_END\n");
    return gen_builder;
}

fn generateStructSetters(cursor: clang.Cursor, allocator: std.mem.Allocator, gen_builder: *BasicString, glue_needed: *bool, header: bool) !void {
    const struct_info = t.CompoundType.fromType(allocator, t.cursorToDeclType(cursor), cursor) catch return;
    defer struct_info.deinit();

    const c_struct_name = try struct_info.cursor.spelling(allocator);
    defer allocator.free(c_struct_name);

    var to_zig: ToZig = undefined;
    if (!isCursorInteresting(struct_info.cursor, allocator, &to_zig)) return;
    if (!to_zig.glue) return;

    glue_needed.* = true;
    for (struct_info.fields.items) |field| {
        const field_name = try field.spelling(allocator);
        defer allocator.free(field_name);
        if (field_name.len == 0) continue;

        const field_c_type = field.c_type();
        const field_c_type_spelling = try field_c_type.spellingFull(allocator);
        defer allocator.free(field_c_type_spelling);

        if (field.isBitField()) {
            if (field.bitWidth()) |_| {
                try gen_builder.appendFmt("void {s}_set_{s}(void *instance_ptr, unsigned value)", .{ c_struct_name, field_name });
            } else continue;
        } else {
            try gen_builder.appendFmt("void {s}_set_{s}(void *instance_ptr, {s} value)", .{ c_struct_name, field_name, field_c_type_spelling });
        }
        if (header) {
            try gen_builder.append(";\n");
        } else {
            try gen_builder.appendFmt(" {{\n    (({s} *)instance_ptr)->{s} = value;\n", .{ c_struct_name, field_name });
            try gen_builder.append("}\n");
        }
    }

    if (header) {
        try gen_builder.append("#ifdef " ++ index_common.glue_cast_define ++ "\n");
        try gen_builder.appendFmt("{0s} *{0s}_castAsPtr(void *ptr) {{ return ({0s} *)ptr; }}\n", .{c_struct_name});
        try gen_builder.appendFmt("{0s} {0s}_castAsValue(void *ptr) {{ return *({0s} *)ptr; }}\n", .{c_struct_name});
        try gen_builder.append("#endif // " ++ index_common.glue_cast_define ++ "\n");
    }
}
